<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZOMBSWAP - Zombie Mall Dice</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Courier', monospace;
            background: #0a0a0a;
            color: #c0c0c0;
            overflow: hidden;
            height: 100vh;
            line-height: 1.4;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: auto;
            padding: 20px;
        }

        /* Canvas for physics - HIDDEN in ASCII mode */
        #physics-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            opacity: 0;
            pointer-events: none;
        }

        /* Main game area */
        #game-board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* ASCII Header */
        #ascii-header {
            text-align: center;
            margin-bottom: 20px;
            color: #00ff00;
            font-size: 12px;
        }

        /* UI Panels - ASCII style */
        #ui-container {
            position: absolute;
            top: 100px;
            left: 20px;
            right: 20px;
            z-index: 100;
            pointer-events: none;
        }

        .ascii-box {
            background: #0a0a0a;
            border: 1px solid #404040;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 13px;
            pointer-events: auto;
        }

        .ascii-box-title {
            color: #00ff00;
            margin-bottom: 5px;
        }

        .resource-line {
            margin: 3px 0;
            color: #c0c0c0;
        }

        .resource-line span {
            color: #ffffff;
        }

        /* Dice Pool Display */
        .dice-pool-line {
            margin: 2px 0;
            font-size: 12px;
        }

        /* Column Layout - ASCII style */
        #column-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            height: 350px;
            display: flex;
            z-index: 3;
            pointer-events: none;
            border: 1px solid #404040;
            background: #0a0a0a;
        }

        .column {
            flex: 1;
            border-left: 1px solid #202020;
            position: relative;
            pointer-events: auto;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .column:hover {
            background-color: #151515;
        }

        .column.selected {
            background-color: #1a3a1a;
            border-left-color: #00ff00;
        }

        /* Column number labels */
        .column::after {
            content: attr(data-column-index);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: #404040;
            font-size: 11px;
        }

        /* Dice Elements - ASCII style */
        .die {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 10;
            font-family: 'Courier New', monospace;
        }

        .die-inner {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.1s;
        }

        .die-face {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            border: 1px solid #303030;
            background: #0a0a0a;
            backface-visibility: hidden;
        }

        /* Bottom UI - Level Selector */
        #level-selector {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
            font-size: 12px;
        }

        .level-btn {
            background: #0a0a0a;
            border: 1px solid #404040;
            color: #808080;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.1s;
        }

        .level-btn:hover {
            background: #151515;
            color: #c0c0c0;
        }

        .level-btn.active {
            background: #1a1a1a;
            color: #00ff00;
            border-color: #00ff00;
        }

        /* Action Buttons - ASCII style */
        #action-panel {
            position: absolute;
            top: 400px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }

        .action-btn {
            background: #0a0a0a;
            border: 1px solid #404040;
            color: #808080;
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 5px;
            transition: all 0.1s;
        }

        .action-btn:hover:not(:disabled) {
            background: #151515;
            color: #c0c0c0;
            border-color: #808080;
        }

        .action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Pegs - ASCII characters */
        .peg {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #303030;
        }

        /* Notifications - ASCII style */
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0a0a0a;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 20px 40px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            display: none;
            text-align: center;
        }

        #notification::before {
            content: "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—";
            display: block;
            margin-bottom: 5px;
        }

        #notification::after {
            content: "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•";
            display: block;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- ASCII Header -->
        <pre id="ascii-header">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                          Z O M B S W A P                              â•‘
â•‘                      Zombie Mall Dice Survival                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        </pre>

        <!-- UI Container -->
        <div id="ui-container">
            <div class="ascii-box" style="width: 300px;">
                <div class="ascii-box-title">â”Œâ”€ RESOURCES â”€â”</div>
                <div class="resource-line">Score: <span id="score-value">0</span></div>
                <div class="resource-line">Zombies: <span id="zombie-value">5</span></div>
                <div class="resource-line">Humans: <span id="human-value">10</span></div>
                <div class="resource-line">Babies: <span id="baby-value">3</span></div>
                <div class="resource-line">Shelters: <span id="shelter-value">0</span></div>
                <div class="ascii-box-title" style="margin-top: 10px;">â”Œâ”€ DICE POOL â”€â”</div>
                <div id="dice-pool-list">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>

        <!-- Physics Canvas (hidden) -->
        <canvas id="physics-canvas"></canvas>

        <!-- Game Board -->
        <div id="game-board">
            <!-- Pegs and dice will be added here dynamically -->
        </div>

        <!-- Column Container -->
        <div id="column-container">
            <!-- 7 columns -->
        </div>

        <!-- Action Panel -->
        <div id="action-panel">
            <button class="action-btn" id="make-baby-btn">[ Make Baby ]</button>
            <button class="action-btn" id="drop-dice-btn">[ Drop Dice ]</button>
        </div>

        <!-- Level Selector -->
        <div id="level-selector">
            <button class="level-btn active" data-level="lobby">[ LOBBY ]</button>
            <button class="level-btn" data-level="food">[ FOOD ]</button>
            <button class="level-btn" data-level="arcade">[ ARCADE ]</button>
            <button class="level-btn" data-level="clothing">[ CLOTHING ]</button>
        </div>

        <!-- Notification -->
        <div id="notification"><div id="notification-text"></div></div>
    </div>

    <script>
        // ========================================
        // GAME STATE
        // ========================================
        const gameState = {
            score: 0,
            zombies: 5,
            humans: 10,
            babies: 3,
            shelters: 0,

            // Dice Pool
            dicePool: {
                mall: 20,
                food: 15,
                arcade: 15,
                clothing: 15
            },

            // Column Management
            columnStacks: [[], [], [], [], [], [], []],
            selectedColumn: null,

            // Level State
            currentLevel: 'lobby',
            levelColumnStates: {},
            zombiesPerStore: {
                food: 3,
                arcade: 3,
                clothing: 3
            },

            // Baby-making
            parentsDice: [],

            // Physics
            diceCounter: 0
        };

        // ========================================
        // DICE CONFIGURATIONS
        // ========================================
        const DICE_SETS = {
            lobby: {
                emojis: ['ğŸ›ï¸', 'ğŸ›’', 'ğŸ’°', 'ğŸ’³', 'ğŸ‘¨', 'ğŸ‘©'],
                poolKey: 'mall'
            },
            food: {
                emojis: ['ğŸ•', 'ğŸ”', 'ğŸŸ', 'ğŸ¥¤', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ‘¨'],
                poolKey: 'food'
            },
            arcade: {
                emojis: ['ğŸ®', 'ğŸ°', 'ğŸ¯', 'ğŸª', 'ğŸ§Ÿâ€â™€ï¸', 'ğŸ‘©'],
                poolKey: 'arcade'
            },
            clothing: {
                emojis: ['ğŸ‘—', 'ğŸ‘š', 'ğŸ‘–', 'ğŸ‘ ', 'ğŸ§Ÿâ€â™‚ï¸', 'ğŸ‘¨'],
                poolKey: 'clothing'
            }
        };

        // ========================================
        // MATTER.JS SETUP
        // ========================================
        const { Engine, Render, World, Bodies, Body, Events } = Matter;

        let engine, render, ground, leftWall, rightWall;
        let activeDice = [];

        function initPhysics() {
            // Create engine
            engine = Engine.create();
            engine.world.gravity.y = 0.5;

            // Create renderer
            const canvas = document.getElementById('physics-canvas');
            render = Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: 'transparent'
                }
            });

            // Create boundaries
            ground = Bodies.rectangle(
                window.innerWidth / 2,
                window.innerHeight + 25,
                window.innerWidth,
                50,
                { isStatic: true, render: { fillStyle: '#00ff88' } }
            );

            leftWall = Bodies.rectangle(
                -25,
                window.innerHeight / 2,
                50,
                window.innerHeight,
                { isStatic: true, render: { fillStyle: '#00ff88' } }
            );

            rightWall = Bodies.rectangle(
                window.innerWidth + 25,
                window.innerHeight / 2,
                50,
                window.innerHeight,
                { isStatic: true, render: { fillStyle: '#00ff88' } }
            );

            World.add(engine.world, [ground, leftWall, rightWall]);

            // Run engine and renderer
            Engine.run(engine);
            Render.run(render);

            // Update dice positions based on physics
            Events.on(engine, 'afterUpdate', updateDicePositions);
        }

        // ========================================
        // COLUMN SETUP
        // ========================================
        function initColumns() {
            const container = document.getElementById('column-container');
            container.innerHTML = '';

            for (let i = 0; i < 7; i++) {
                const column = document.createElement('div');
                column.className = 'column';
                column.dataset.columnIndex = i;

                column.addEventListener('click', () => handleColumnClick(i));

                container.appendChild(column);
            }
        }

        function handleColumnClick(columnIndex) {
            if (gameState.selectedColumn === null) {
                // Select this column
                gameState.selectedColumn = columnIndex;
                updateColumnVisuals();
            } else if (gameState.selectedColumn === columnIndex) {
                // Deselect
                gameState.selectedColumn = null;
                updateColumnVisuals();
            } else if (Math.abs(gameState.selectedColumn - columnIndex) === 1) {
                // Swap adjacent columns
                swapColumns(gameState.selectedColumn, columnIndex);
                gameState.selectedColumn = null;
                updateColumnVisuals();
            } else {
                // Select new column
                gameState.selectedColumn = columnIndex;
                updateColumnVisuals();
            }
        }

        function swapColumns(col1, col2) {
            if (gameState.columnStacks[col1].length === 0 || gameState.columnStacks[col2].length === 0) {
                return; // Can't swap if column is empty
            }

            // Get top dice from each column
            const dice1 = gameState.columnStacks[col1][gameState.columnStacks[col1].length - 1];
            const dice2 = gameState.columnStacks[col2][gameState.columnStacks[col2].length - 1];

            // Swap their emojis
            const tempEmoji = dice1.emoji;
            dice1.emoji = dice2.emoji;
            dice2.emoji = dice1.emoji;

            // Update visual
            dice1.element.querySelector('.die-face').textContent = dice1.emoji;
            dice2.element.querySelector('.die-face').textContent = dice2.emoji;

            // Update face colors
            updateDieFaceColor(dice1);
            updateDieFaceColor(dice2);

            // Check for matches
            setTimeout(() => checkAllMatches(), 300);
        }

        function updateColumnVisuals() {
            const columns = document.querySelectorAll('.column');
            columns.forEach((col, index) => {
                if (index === gameState.selectedColumn) {
                    col.classList.add('selected');
                } else {
                    col.classList.remove('selected');
                }
            });
        }

        // ========================================
        // DICE CREATION
        // ========================================
        function createDice(x, y, diceSet) {
            const emojis = diceSet.emojis;
            const emoji = emojis[Math.floor(Math.random() * emojis.length)];

            // Create physics body
            const body = Bodies.rectangle(x, y, 40, 40, {
                restitution: 0.6,
                friction: 0.01,
                frictionAir: 0.01
            });

            World.add(engine.world, body);

            // Create DOM element
            const dieElement = document.createElement('div');
            dieElement.className = 'die';
            dieElement.style.left = x + 'px';
            dieElement.style.top = y + 'px';

            const dieInner = document.createElement('div');
            dieInner.className = 'die-inner';

            const dieFace = document.createElement('div');
            dieFace.className = 'die-face';
            dieFace.textContent = emoji;

            dieInner.appendChild(dieFace);
            dieElement.appendChild(dieInner);
            document.getElementById('game-board').appendChild(dieElement);

            const diceObject = {
                id: gameState.diceCounter++,
                body: body,
                element: dieElement,
                emoji: emoji,
                settled: false,
                columnIndex: null,
                tumbleInterval: null
            };

            activeDice.push(diceObject);

            // Start tumbling animation
            startTumbling(diceObject);

            return diceObject;
        }

        function startTumbling(dice) {
            const diceSet = DICE_SETS[gameState.currentLevel];
            const emojis = diceSet.emojis;

            dice.tumbleInterval = setInterval(() => {
                if (!dice.settled) {
                    // Random emoji while falling
                    dice.emoji = emojis[Math.floor(Math.random() * emojis.length)];
                    dice.element.querySelector('.die-face').textContent = dice.emoji;
                    updateDieFaceColor(dice);

                    // Random rotation
                    const rx = Math.random() * 360;
                    const ry = Math.random() * 360;
                    const rz = Math.random() * 360;
                    dice.element.querySelector('.die-inner').style.transform =
                        `rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`;
                }
            }, 150);
        }

        function updateDieFaceColor(dice) {
            const face = dice.element.querySelector('.die-face');
            const emoji = dice.emoji;

            // ASCII-style - minimal color coding
            if (emoji === 'ğŸ§Ÿâ€â™‚ï¸' || emoji === 'ğŸ§Ÿâ€â™€ï¸' || emoji === 'ğŸ’€') {
                face.style.backgroundColor = '#0a0a0a';
                face.style.borderColor = '#00ff00';
                face.style.color = '#00ff00';
            } else if (emoji === 'ğŸ‘¨' || emoji === 'ğŸ‘©') {
                face.style.backgroundColor = '#0a0a0a';
                face.style.borderColor = '#808080';
                face.style.color = '#ffffff';
            } else if (emoji === 'ğŸ”¥') {
                face.style.backgroundColor = '#0a0a0a';
                face.style.borderColor = '#ff0000';
                face.style.color = '#ff0000';
            } else if (emoji === 'ğŸ’°' || emoji === 'ğŸ’³') {
                face.style.backgroundColor = '#0a0a0a';
                face.style.borderColor = '#ffff00';
                face.style.color = '#ffff00';
            } else {
                face.style.backgroundColor = '#0a0a0a';
                face.style.borderColor = '#404040';
                face.style.color = '#c0c0c0';
            }
        }

        // ========================================
        // PHYSICS UPDATE
        // ========================================
        function updateDicePositions() {
            activeDice.forEach(dice => {
                if (!dice.settled) {
                    // Update position
                    dice.element.style.left = (dice.body.position.x - 20) + 'px';
                    dice.element.style.top = (dice.body.position.y - 20) + 'px';

                    // Check if settled
                    if (dice.body.position.y > window.innerHeight - 450 &&
                        Math.abs(dice.body.velocity.y) < 0.1) {
                        settleDice(dice);
                    }
                }
            });
        }

        function settleDice(dice) {
            dice.settled = true;
            clearInterval(dice.tumbleInterval);

            // Remove physics body
            World.remove(engine.world, dice.body);

            // Determine column
            const containerRect = document.getElementById('column-container').getBoundingClientRect();
            const diceX = dice.body.position.x;
            const columnWidth = containerRect.width / 7;
            const relativeX = diceX - (window.innerWidth - containerRect.width) / 2;
            const columnIndex = Math.floor(relativeX / columnWidth);

            if (columnIndex >= 0 && columnIndex < 7) {
                addDiceToColumn(dice, columnIndex);
            } else {
                // Out of bounds, remove
                dice.element.remove();
                activeDice = activeDice.filter(d => d.id !== dice.id);
            }
        }

        function addDiceToColumn(dice, columnIndex) {
            dice.columnIndex = columnIndex;
            gameState.columnStacks[columnIndex].push(dice);

            // Position in column
            const stackHeight = gameState.columnStacks[columnIndex].length;
            const containerRect = document.getElementById('column-container').getBoundingClientRect();
            const columnWidth = containerRect.width / 7;

            const newX = containerRect.left + (columnIndex * columnWidth) + (columnWidth / 2);
            const newY = containerRect.bottom - (stackHeight * 45) - 20;

            dice.element.style.left = (newX - 20) + 'px';
            dice.element.style.top = (newY - 20) + 'px';
            dice.element.style.transition = 'all 0.3s ease';

            // Reset rotation
            dice.element.querySelector('.die-inner').style.transform = 'rotateX(0) rotateY(0) rotateZ(0)';

            // Check for matches after settling
            setTimeout(() => checkAllMatches(), 500);
        }

        // ========================================
        // MATCH DETECTION
        // ========================================
        function checkAllMatches() {
            let matchFound = false;

            // Check vertical matches
            for (let col = 0; col < 7; col++) {
                if (checkVerticalMatch(col)) {
                    matchFound = true;
                }
            }

            // Check horizontal matches
            if (checkHorizontalMatches()) {
                matchFound = true;
            }

            if (matchFound) {
                // Re-check after matches resolve
                setTimeout(() => checkAllMatches(), 800);
            }
        }

        function checkVerticalMatch(columnIndex) {
            const stack = gameState.columnStacks[columnIndex];
            if (stack.length < 2) return false;

            for (let i = 0; i < stack.length - 1; i++) {
                const dice1 = stack[i];
                const dice2 = stack[i + 1];

                if (dice1.emoji === dice2.emoji) {
                    // Match found!
                    processMatch([dice1, dice2], false);
                    return true;
                }
            }

            return false;
        }

        function checkHorizontalMatches() {
            const topDice = [];

            for (let col = 0; col < 7; col++) {
                const stack = gameState.columnStacks[col];
                if (stack.length > 0) {
                    topDice.push({ dice: stack[stack.length - 1], col: col });
                } else {
                    topDice.push(null);
                }
            }

            // Find consecutive matches
            for (let i = 0; i < topDice.length - 1; i++) {
                if (!topDice[i]) continue;

                const matches = [topDice[i]];

                for (let j = i + 1; j < topDice.length; j++) {
                    if (topDice[j] && topDice[j].dice.emoji === topDice[i].dice.emoji) {
                        matches.push(topDice[j]);
                    } else {
                        break;
                    }
                }

                if (matches.length >= 2) {
                    const isSuper = matches.length >= 3;
                    processMatch(matches.map(m => m.dice), isSuper);
                    return true;
                }
            }

            return false;
        }

        // ========================================
        // MATCH PROCESSING
        // ========================================
        function processMatch(diceArray, isSuper) {
            const emoji = diceArray[0].emoji;
            const matchCount = diceArray.length;

            // Remove matched dice
            diceArray.forEach(dice => {
                removeDiceFromColumn(dice);
            });

            // Apply effects based on emoji
            applyMatchEffect(emoji, matchCount, isSuper);

            // Visual feedback
            showNotification(`${isSuper ? 'SUPER ' : ''}MATCH! ${emoji} x${matchCount}`);
        }

        function removeDiceFromColumn(dice) {
            if (dice.columnIndex !== null) {
                const stack = gameState.columnStacks[dice.columnIndex];
                const index = stack.indexOf(dice);
                if (index > -1) {
                    stack.splice(index, 1);
                }

                // Re-position remaining dice
                repositionColumn(dice.columnIndex);
            }

            // Remove from active dice
            activeDice = activeDice.filter(d => d.id !== dice.id);

            // Animate out
            dice.element.style.transition = 'all 0.3s ease';
            dice.element.style.opacity = '0';
            dice.element.style.transform = 'scale(1.5)';
            setTimeout(() => dice.element.remove(), 300);
        }

        function repositionColumn(columnIndex) {
            const stack = gameState.columnStacks[columnIndex];
            const containerRect = document.getElementById('column-container').getBoundingClientRect();
            const columnWidth = containerRect.width / 7;

            stack.forEach((dice, index) => {
                const stackHeight = index + 1;
                const newX = containerRect.left + (columnIndex * columnWidth) + (columnWidth / 2);
                const newY = containerRect.bottom - (stackHeight * 45) - 20;

                dice.element.style.left = (newX - 20) + 'px';
                dice.element.style.top = (newY - 20) + 'px';
            });
        }

        // ========================================
        // MATCH EFFECTS
        // ========================================
        function applyMatchEffect(emoji, matchCount, isSuper) {
            const baseScore = isSuper ? 30 : 10;

            if (emoji === 'ğŸ‘¨' || emoji === 'ğŸ‘©') {
                // Human match
                if (gameState.currentLevel === 'lobby') {
                    gameState.humans += matchCount;
                    gameState.score += 5 * matchCount;
                } else {
                    // Trigger search in stores
                    gameState.score += 5 * matchCount;
                }
            } else if (emoji === 'ğŸ§Ÿâ€â™‚ï¸' || emoji === 'ğŸ§Ÿâ€â™€ï¸') {
                // Zombie match
                gameState.zombies = Math.max(0, gameState.zombies - matchCount);
                if (gameState.currentLevel !== 'lobby') {
                    gameState.zombiesPerStore[gameState.currentLevel] =
                        Math.max(0, gameState.zombiesPerStore[gameState.currentLevel] - matchCount);
                }
                gameState.score += 15 * matchCount;
            } else if (emoji === 'ğŸ’°' || emoji === 'ğŸ’³') {
                // Money match
                const diceGained = isSuper ? 8 : 3;
                const poolKey = DICE_SETS[gameState.currentLevel].poolKey;
                gameState.dicePool[poolKey] += diceGained;
                gameState.score += 25 * matchCount;
            } else if (emoji === 'ğŸ”¥') {
                // Fire match
                gameState.score += 10 * matchCount;
                // TODO: Fire spread mechanic
            } else {
                // Generic match
                const diceGained = isSuper ? 5 : 1;
                const poolKey = DICE_SETS[gameState.currentLevel].poolKey;
                gameState.dicePool[poolKey] += diceGained;
                gameState.score += baseScore * matchCount;
            }

            updateUI();
        }

        // ========================================
        // UI UPDATES
        // ========================================
        function updateUI() {
            document.getElementById('score-value').textContent = gameState.score;
            document.getElementById('zombie-value').textContent = gameState.zombies;
            document.getElementById('human-value').textContent = gameState.humans;
            document.getElementById('baby-value').textContent = gameState.babies;
            document.getElementById('shelter-value').textContent = gameState.shelters;

            updateDicePoolDisplay();
            updateActionButtons();
        }

        function updateDicePoolDisplay() {
            const poolList = document.getElementById('dice-pool-list');
            poolList.innerHTML = '';

            const poolLabels = {
                mall: 'Mall',
                food: 'Food',
                arcade: 'Arcade',
                clothing: 'Cloth'
            };

            for (const [key, label] of Object.entries(poolLabels)) {
                const item = document.createElement('div');
                item.className = 'dice-pool-line';
                item.innerHTML = `${label.padEnd(8, '.')} ${gameState.dicePool[key]}`;
                poolList.appendChild(item);
            }
        }

        function updateActionButtons() {
            const makeBabyBtn = document.getElementById('make-baby-btn');
            const dropDiceBtn = document.getElementById('drop-dice-btn');

            // Make Baby button
            if (gameState.currentLevel === 'lobby' && gameState.humans >= 2) {
                makeBabyBtn.disabled = false;
            } else {
                makeBabyBtn.disabled = true;
            }

            // Drop Dice button
            const poolKey = DICE_SETS[gameState.currentLevel].poolKey;
            if (gameState.dicePool[poolKey] > 0) {
                dropDiceBtn.disabled = false;
            } else {
                dropDiceBtn.disabled = true;
            }
        }

        // ========================================
        // ACTIONS
        // ========================================
        function makeBaby() {
            if (gameState.humans >= 2 && gameState.currentLevel === 'lobby') {
                gameState.humans -= 2;
                gameState.babies += 1;

                showNotification('ğŸ‘¶ Baby Created!');
                updateUI();
            }
        }

        function dropDice() {
            const poolKey = DICE_SETS[gameState.currentLevel].poolKey;

            if (gameState.dicePool[poolKey] > 0) {
                gameState.dicePool[poolKey]--;

                const x = window.innerWidth / 2 + (Math.random() - 0.5) * 200;
                const y = 50;

                createDice(x, y, DICE_SETS[gameState.currentLevel]);
                updateUI();
            }
        }

        // ========================================
        // LEVEL MANAGEMENT
        // ========================================
        function switchLevel(levelName) {
            // Save current level state
            if (gameState.currentLevel) {
                saveColumnState(gameState.currentLevel);
            }

            gameState.currentLevel = levelName;

            // Clear pegs and walls
            clearLevel();

            // Load new level
            setupLevel(levelName);

            // Restore level state
            restoreColumnState(levelName);

            // Update UI
            updateLevelButtons();
            updateUI();
        }

        function saveColumnState(levelName) {
            gameState.levelColumnStates[levelName] = gameState.columnStacks.map(stack =>
                stack.map(dice => ({ emoji: dice.emoji }))
            );
        }

        function restoreColumnState(levelName) {
            // Clear columns
            gameState.columnStacks = [[], [], [], [], [], [], []];
            activeDice.forEach(dice => dice.element.remove());
            activeDice = [];

            // Restore saved state
            if (gameState.levelColumnStates[levelName]) {
                const savedState = gameState.levelColumnStates[levelName];
                savedState.forEach((stack, colIndex) => {
                    stack.forEach(diceData => {
                        // Create dice element (not physics body)
                        const diceObject = createRestoredDice(diceData.emoji, colIndex);
                        gameState.columnStacks[colIndex].push(diceObject);
                    });
                });

                // Reposition all columns
                for (let i = 0; i < 7; i++) {
                    repositionColumn(i);
                }
            }
        }

        function createRestoredDice(emoji, columnIndex) {
            const dieElement = document.createElement('div');
            dieElement.className = 'die';

            const dieInner = document.createElement('div');
            dieInner.className = 'die-inner';

            const dieFace = document.createElement('div');
            dieFace.className = 'die-face';
            dieFace.textContent = emoji;

            dieInner.appendChild(dieFace);
            dieElement.appendChild(dieInner);
            document.getElementById('game-board').appendChild(dieElement);

            const diceObject = {
                id: gameState.diceCounter++,
                body: null,
                element: dieElement,
                emoji: emoji,
                settled: true,
                columnIndex: columnIndex,
                tumbleInterval: null
            };

            updateDieFaceColor(diceObject);
            activeDice.push(diceObject);

            return diceObject;
        }

        function clearLevel() {
            // Remove all pegs and walls from physics world
            const pegsAndWalls = document.querySelectorAll('.peg, .wall');
            pegsAndWalls.forEach(el => el.remove());

            // Clear physics bodies (except boundaries)
            World.clear(engine.world, false);
            World.add(engine.world, [ground, leftWall, rightWall]);
        }

        function setupLevel(levelName) {
            const pegConfigs = {
                lobby: { shape: 'circle', color: '#4a9eff', size: 20 },
                food: { shape: 'square', color: '#ff4a4a', size: 20 },
                arcade: { shape: 'diamond', color: '#4affe8', size: 20 },
                clothing: { shape: 'square', color: '#ff88dd', size: 20 }
            };

            const config = pegConfigs[levelName];
            createPegs(config);
        }

        function createPegs(config) {
            const containerRect = document.getElementById('column-container').getBoundingClientRect();
            const columnWidth = containerRect.width / 7;
            const pegArea = { top: 150, bottom: containerRect.top };

            // ASCII characters for different peg types
            const pegChars = {
                circle: 'â—',
                square: 'â– ',
                diamond: 'â—†'
            };

            const pegChar = pegChars[config.shape] || 'â—';

            // Create pegs
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 7; col++) {
                    // Skip center of columns to allow clear paths
                    if (Math.random() > 0.3) continue;

                    const x = containerRect.left + col * columnWidth + columnWidth / 2 + (Math.random() - 0.5) * 40;
                    const y = pegArea.top + row * 50 + (Math.random() - 0.5) * 20;

                    // Add physics peg
                    const pegBody = Bodies.circle(x, y, config.size / 2, {
                        isStatic: true,
                        restitution: 0.8,
                        friction: 0.005,
                        render: { visible: false }
                    });
                    World.add(engine.world, pegBody);

                    // Add visual peg (ASCII character)
                    const pegElement = document.createElement('div');
                    pegElement.className = 'peg';
                    pegElement.textContent = pegChar;
                    pegElement.style.left = (x - 7) + 'px';
                    pegElement.style.top = (y - 10) + 'px';
                    document.getElementById('game-board').appendChild(pegElement);
                }
            }
        }

        function updateLevelButtons() {
            const buttons = document.querySelectorAll('.level-btn');
            buttons.forEach(btn => {
                if (btn.dataset.level === gameState.currentLevel) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // ========================================
        // NOTIFICATIONS
        // ========================================
        function showNotification(message) {
            const notif = document.getElementById('notification');
            const notifText = document.getElementById('notification-text');
            notifText.textContent = message;
            notif.style.display = 'block';

            setTimeout(() => {
                notif.style.display = 'none';
            }, 1500);
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================
        document.getElementById('make-baby-btn').addEventListener('click', makeBaby);
        document.getElementById('drop-dice-btn').addEventListener('click', dropDice);

        document.querySelectorAll('.level-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchLevel(btn.dataset.level);
            });
        });

        // ========================================
        // INITIALIZATION
        // ========================================
        function init() {
            initPhysics();
            initColumns();
            setupLevel('lobby');
            updateUI();
        }

        // Start the game
        init();
    </script>
</body>
</html>
